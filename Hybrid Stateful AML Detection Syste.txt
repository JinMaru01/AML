Hybrid Stateful AML Detection System
1. Overview
1.1 Purpose

This document describes the design of a hybrid, stateful Anti-Money Laundering (AML) detection system that combines:

Rule-based automata (deterministic logic)

Real-time state storage (Redis)

Anomaly detection models

Supervised risk classification

The goal is to detect and score suspicious financial behavior across:

Placement

Layering

Integration

1.2 Design Principles

Real-time capable

Explainable and regulator-aligned

Scalable and distributed

Hybrid symbolic + ML architecture

Separation of signal generation and final decision

2. System Architecture
2.1 High-Level Architecture
Transaction Stream
        ↓
Feature Extraction Layer
        ↓
Automata / Rule Engine
        ↓
Redis State Store
        ↓
Anomaly Detection Models
        ↓
Risk Classification Engine
        ↓
Alert & Case Management

3. Component Design
3.1 Transaction Ingestion Layer
Responsibilities

Receive transaction stream (real-time or batch)

Validate schema

Normalize currency, timestamps, account identifiers

Input
{
  "timestamp": "...",
  "from_account": "...",
  "to_account": "...",
  "amount": ...,
  "currency": "...",
  "country": "..."
}

Output

Normalized transaction event

3.2 Feature Extraction Layer
Responsibilities

Generate behavioral features:

Account-level features

Rolling 24h transaction count

7-day total volume

Unique counterparties count

Velocity (time between transactions)

Cross-border flag

Sequence features

In-out ratio

Rapid fund movement indicator

Circular transfer indicator (optional graph extension)

Features are:

Calculated using historical state in Redis

Passed to rule engine and ML models

3.3 Automata / Rule Engine
3.3.1 Purpose

Detect known laundering patterns using deterministic logic.

3.3.2 Pattern Types
Placement

Structured deposits

Large cash thresholds

Dormant account activation

Layering

Rapid multi-hop transfers

High counterparty churn

Burst activity

Integration

Income-spending mismatch

Unusual business pattern

3.3.3 Finite State Machine (FSM)

Each account has a behavioral state.

Example:

STATE_NORMAL
   ↓ deposit spike
STATE_STRUCTURING
   ↓ rapid transfer
STATE_LAYERING
   ↓ multi-hop detected
STATE_HIGH_RISK


State transitions stored in Redis.

3.4 Redis State Layer
3.4.1 Role

Redis acts as:

Real-time behavioral memory

FSM state storage

Rolling window counter storage

Feature cache

3.4.2 Example Data Structure
Key: account:12345

{
  "fsm_state": "LAYERING_STAGE_2",
  "last_24h_tx_count": 18,
  "last_7d_volume": 480000,
  "unique_counterparties_7d": 14,
  "risk_counter": 3,
  "last_updated": "timestamp"
}


TTL used for rolling windows.

3.4.3 Why Redis

Low latency

High throughput

Good for counters and state transitions

Horizontal scaling possible

3.5 Anomaly Detection Layer
3.5.1 Purpose

Detect previously unseen suspicious patterns.

3.5.2 Models
Transaction-level anomaly

Isolation Forest

Statistical deviation (z-score)

Sequence-level anomaly

Rolling behavioral deviation score

Optional LSTM for temporal modeling

3.5.3 Output
{
  "transaction_anomaly_score": 0.82,
  "sequence_anomaly_score": 0.65
}


Scores normalized to [0,1]

3.6 Risk Classification Engine
3.6.1 Purpose

Combine all signals into a final risk score.

3.6.2 Inputs

Rule hit count

FSM risk state

Transaction anomaly score

Sequence anomaly score

Behavioral aggregates

Optional graph risk score

3.6.3 Model Options

Logistic Regression (high explainability)

XGBoost (strong baseline)

Random Forest

3.6.4 Risk Aggregation

Example formula:

Final Risk =
  w1 * rule_score +
  w2 * anomaly_score +
  w3 * sequence_score +
  w4 * classifier_probability


Output:

{
  "risk_score": 0.87,
  "risk_level": "HIGH"
}

3.7 Alert & Action Layer
3.7.1 Trigger Conditions

Risk score > threshold

FSM state = HIGH_RISK

Critical rule hit

3.7.2 Actions

Generate alert

Escalate to analyst

Freeze transaction (if real-time)

Create SAR report

4. Data Flow
Real-Time Flow
Transaction →
Feature update →
FSM update →
Redis state update →
Anomaly scoring →
Classification →
Risk decision →
Alert (if needed)

5. Scalability Considerations

Stateless processing nodes

Redis cluster for state

Horizontal scaling of model inference

Async case management

6. Explainability & Compliance
Rule engine

Fully explainable.

FSM

State transitions logged.

ML model

Feature importance stored

SHAP values optional

All decisions logged for audit trail.

7. Optional Extensions

Graph database for network risk

Knowledge graph integration

Dynamic thresholding

Reinforcement learning for threshold optimization

8. Strengths of Design

Hybrid symbolic + ML

Real-time capable

Regulator-friendly

Modular architecture

Extensible to graph analytics

Supports placement, layering, integration stages

9. Future Improvements

Add graph neural networks

Add behavioral segmentation

Add adaptive thresholds

Add feedback loop from analyst decisions

Final System Summary

This AML system is a stateful hybrid detection platform that:

Uses automata to detect known laundering patterns

Stores behavioral state in Redis

Applies anomaly detection for unknown patterns

Uses supervised classification for final risk scoring

Produces explainable, auditable alerts